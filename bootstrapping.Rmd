---
title: "The Bootstrap"
author: "John Clements"
date: "2/26/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Requirements

- `parallel`: for parallel computation
- `tidyquant`: for access to financial data
- `ggplot2`: for data visualization

```{r}
suppressMessages(library(parallel))
suppressMessages(library(tidyquant))
suppressMessages(library(ggplot2))
```


# I. Introduction

# II. Technical Implementation

## A. Single Bootstrap Function


```{r}
one_bootstrap <- function(my_vec, my_func){
  ###
  # This function retrieves one bootstrapped sample and returns the statistic
  # of interest.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  #
  # Returns
  # -------
  # double
  #   The statistic of interest computed on the bootstrapped sample.
  #
  ###
  bootstrapped_sample <- sample(my_vec, size=length(my_vec), replace=TRUE)
  return(my_func(bootstrapped_sample))
}
```

## B. Bootstrap Loop

```{r}
bootstrap_loop <- function(my_vec, my_func, B){
  ###
  # This function takes in a data vector, function, and the number of bootstrap
  # iterations and returns a list holding the mean and standard deviation of the 
  # bootstrap estimates as well, as the vector of the bootstrap estimates. It
  # utilizes a for loop.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  # B : int
  #   The number of bootstrapped samples to return.
  #
  # Returns
  # -------
  # output : list
  #   A list of the mean, and standard deviation of the estimates and a vector
  #   of the estimates.
  #
  ###
  estimates <- rep(NA, B)
  for (i in 1:B){
    estimates[i] <- one_bootstrap(my_vec, my_func)
  }
  output <- list(
    'mean' = mean(estimates),
    'se' = sd(estimates),
    'estimates' = estimates
  )
  return(output)
}
```

## C. Bootstrap Replicate

```{r}
bootstrap_replicate <- function(my_vec, my_func, B){
  ###
  # This function takes in a data vector, function, and the number of bootstrap
  # iterations and returns a list holding the mean and standard deviation of the 
  # bootstrap estimates as well, as the vector of the bootstrap estimates. It
  # utilizes the replicate function for optimized looping.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  # B : int
  #   The number of bootstrapped samples to return.
  #
  # Returns
  # -------
  # output : list
  #   A list of the mean, and standard deviation of the estimates and a vector
  #   of the estimates.
  #
  ###
  estimates <- replicate(B, one_bootstrap(my_vec, my_func))
  output <- list(
    'mean' = mean(estimates),
    'se' = sd(estimates),
    'estimates' = estimates
  )
  return(output)
}
```

## D. Parallelized Bootstrapping


```{r}
bootstrap_replicate_par <- function(B, my_vec, my_func){
  ###
  # This function is a helper function for the parallized bootstrapping function.
  # It takes in a vector whose length determines the number of bootstrap samples
  # to take, a data vector, and a function. It returns the list of bootstrapped
  # estimates from my_func.
  #
  # Args
  # ----
  # B : vecot
  #   A vector whose length determines of bootstrapped samples to return.
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  #
  # Returns
  # -------
  # estimates : vector
  #   A vector of the estimates.
  #
  ###
  estimates <- replicate(length(B), one_bootstrap(my_vec, my_func))
  return(estimates)
}
```

```{r}
bootstrap_parallel <- function(my_vec, my_func, B){
  ###
  # This function takes in a data vector, function, and the number of bootstrap
  # iterations and returns a list holding the mean and standard deviation of the 
  # bootstrap estimates as well, as the vector of the bootstrap estimates. It
  # utilizes parallel computing.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  # B : int
  #   The number of bootstrapped samples to return.
  #
  # Returns
  # -------
  # output : list
  #   A list of the mean, and standard deviation of the estimates and a vector
  #   of the estimates.
  #
  ###
  
  # Count the cores and make a cluster from leaving one core free.
  cores <- detectCores()  
  cluster <- makeCluster(cores - 1)

  # Create a vector that will be split up and determine the number of bootstrap
  # samples to get on each core.
  boot_vec <- 1:B
  
  # Export functions to the cluster.
  clusterExport(
    cluster, 
    list("boot_vec", "one_bootstrap", "bootstrap_replicate_par", "my_vec",
         "my_func"),
    envir=environment()
    )

  estimates <- parSapply(
    cluster,
    boot_vec,
    FUN=bootstrap_replicate_par,
    my_vec=my_vec,
    my_func=my_func
    )

  stopCluster(cluster)

  output <- list(
    'mean' = mean(estimates),
    'se' = sd(estimates),
    'estimates' = estimates
  )

  return(output)
}
```


# Applications

## A. Data Set-up

```{r, echo=False}
start_date <- '2016-01-01'
end_date <- '2021-12-31'

getSymbols(
  "^GSPC",
  from=start_date,
  to=end_date,
  warnings=FALSE,
  auto.assign=TRUE
  )

adj_close <- as.vector(GSPC$GSPC.Adjusted)
trading_days <- length(adj_close)
returns <- tail(adj_close, trading_days-1) / head(adj_close, trading_days-1) - 1
```

```{r, include=FALSE}
# Create a single-column DataFrame of returns for use with ggplot. 
returns_df <- as.data.frame(returns)

# Create a histogram of daily returns with a KDE overlayed.
returns_hist <- ggplot(returns_df, aes(x=returns)) +
  geom_histogram(aes(y = after_stat(density)),
                 color='darkblue',
                 fill='lightblue',
                 position = 'identity',
                 bins=30) +
  geom_density(bw=0.0025, color='red', size=1.5) + 
  labs(
    title=paste0('S&P 500 Daily Returns (', start_date, ' to ', end_date, ')'),
    x='returns',
    y='density'
    )

returns_hist
```


## B. Sharpe Ratio


```{r}
sharpe_ratio <- function(returns){
  return(mean(returns)/sd(returns))
}
```

```{r}
sharpe_est <- sharpe_ratio(returns)
sharpe_est
```

```{r}
set.seed(1)
B <- 100000

ptm_loop <- proc.time()
sharpe_est_loop <- bootstrap_loop(returns, sharpe_ratio, B)
loop_time <- proc.time() - ptm_loop

ptm_repl <- proc.time()
sharpe_est_repl <- bootstrap_parallel(returns, sharpe_ratio, B)
repl_time <- proc.time() - ptm_repl

ptm_par <- proc.time()
sharpe_est_par <- bootstrap_parallel(returns, sharpe_ratio, B)
par_time <- proc.time() - ptm_par
```


```{r, include=FALSE}
labels <- c('For Loop', 'Optimized Loop', 'Parallelized')
mean_ests <- c(sharpe_est_loop$mean, sharpe_est_repl$mean, sharpe_est_par$mean)
se_ests <- c(sharpe_est_loop$std, sharpe_est_repl$std, sharpe_est_par$std)
elapsed <- matrix(c(loop_time, repl_time, par_time), nrow=3, byrow=TRUE)[,3]
results_df <- as.data.frame(
  list('Method'=labels, 'Mean'=mean_ests, 'SE'=se_ests, 'RunTime'=elapsed)
  )

knitr::kable(
  results_df, 
  caption='Comparison of Bootstrap Estimeates of Sharpe Ratio'
  )
```

```{r, incude=False}
bootstrap_sharpe_df <- as.data.frame(list('sharpe'=sharpe_est_par$estimates))

df <- trading_days - 2
quantiles <- -400:400 / 100
x <- sharpe_est + quantiles*sharpe_est_par$std
densities <- dt(quantiles, df=df)
t_dist_df <- as.data.frame(list('x'=x, 'density'=densities))

# Define a Student t distribution with shape (nu) and location (mu)
# source: https://stackoverflow.com/questions/46848998/superimposing-asymmetric-t-distribution-using-ggplot2
dt2 <- function(x, mu, nu, df, ncp) {
  dt((x-mu)/nu, df, ncp) / nu
}

ggplot(bootstrap_sharpe_df, aes(x=sharpe)) +
  geom_histogram(
    aes(y=(..density..)),
    color='darkblue',
    fill='lightblue',
    position = 'identity',
    bins=30) +
  stat_function(
    fun=dt2,
    args=list(mu=sharpe_est_par$mean, nu=sharpe_est_par$std, df=df),
    color='red',
    lwd=1
    ) +
  labs(
    title='Bootstrapped Distribution of Sharpe Ratio',
    x='returns',
    y='density'
    )

```

```{r}
max(densities)
```


## B. Value at Risk and Expected Shortfall






