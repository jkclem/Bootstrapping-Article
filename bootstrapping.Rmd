---
title: "The Bootstrap"
author: "John Clements"
date: "2/26/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Requirements

- `parallel`: for parallel computation
- `tidyquant`: for access to financial data
- `ggplot2`: for data visualization

```{r}
suppressMessages(library(parallel))
suppressMessages(library(tidyquant))
suppressMessages(library(ggplot2))
```


# I. Introduction

When estimating a statistic of interest, we are not only interested in the point-value of that statistic. We also want to quantify our uncertainty about our estimate

# II. Technical Implementation

## A. Single Bootstrap Function


```{r}
one_bootstrap <- function(my_vec, my_func){
  ###
  # This function retrieves one bootstrapped sample and returns the statistic
  # of interest.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  #
  # Returns
  # -------
  # double
  #   The statistic of interest computed on the bootstrapped sample.
  #
  ###
  bootstrapped_sample <- sample(my_vec, size=length(my_vec), replace=TRUE)
  return(my_func(bootstrapped_sample))
}
```

## B. Bootstrap Loop

```{r}
bootstrap_loop <- function(my_vec, my_func, B){
  ###
  # This function takes in a data vector, function, and the number of bootstrap
  # iterations and returns a list holding the mean and standard deviation of the 
  # bootstrap estimates as well, as the vector of the bootstrap estimates. It
  # utilizes a for loop.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  # B : int
  #   The number of bootstrapped samples to return.
  #
  # Returns
  # -------
  # output : list
  #   A list of the mean, and standard deviation of the estimates and a vector
  #   of the estimates.
  #
  ###
  estimates <- rep(NA, B)
  for (i in 1:B){
    estimates[i] <- one_bootstrap(my_vec, my_func)
  }
  output <- list(
    'mean' = mean(estimates),
    'se' = sd(estimates),
    'estimates' = estimates
  )
  return(output)
}
```

## C. Bootstrap Replicate

```{r}
bootstrap_replicate <- function(my_vec, my_func, B){
  ###
  # This function takes in a data vector, function, and the number of bootstrap
  # iterations and returns a list holding the mean and standard deviation of the 
  # bootstrap estimates as well, as the vector of the bootstrap estimates. It
  # utilizes the replicate function for optimized looping.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  # B : int
  #   The number of bootstrapped samples to return.
  #
  # Returns
  # -------
  # output : list
  #   A list of the mean, and standard deviation of the estimates and a vector
  #   of the estimates.
  #
  ###
  estimates <- replicate(B, one_bootstrap(my_vec, my_func))
  output <- list(
    'mean' = mean(estimates),
    'se' = sd(estimates),
    'estimates' = estimates
  )
  return(output)
}
```

## D. Parallelized Bootstrapping


```{r}
bootstrap_replicate_par <- function(B, my_vec, my_func){
  ###
  # This function is a helper function for the parallized bootstrapping function.
  # It takes in a vector whose length determines the number of bootstrap samples
  # to take, a data vector, and a function. It returns the list of bootstrapped
  # estimates from my_func.
  #
  # Args
  # ----
  # B : vecot
  #   A vector whose length determines of bootstrapped samples to return.
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  #
  # Returns
  # -------
  # estimates : vector
  #   A vector of the estimates.
  #
  ###
  estimates <- replicate(length(B), one_bootstrap(my_vec, my_func))
  return(estimates)
}
```

```{r}
bootstrap_parallel <- function(my_vec, my_func, B){
  ###
  # This function takes in a data vector, function, and the number of bootstrap
  # iterations and returns a list holding the mean and standard deviation of the 
  # bootstrap estimates as well, as the vector of the bootstrap estimates. It
  # utilizes parallel computing.
  #
  # Args
  # ----
  # my_vec : numeric vector
  #   A vector of numbers of which to compute the statistic of interest.
  # my_func : function
  #   Function which computes the statistic of interest.
  # B : int
  #   The number of bootstrapped samples to return.
  #
  # Returns
  # -------
  # output : list
  #   A list of the mean, and standard deviation of the estimates and a vector
  #   of the estimates.
  #
  ###
  
  # Count the cores and make a cluster from leaving one core free.
  cores <- detectCores()  
  cluster <- makeCluster(cores - 1)

  # Create a vector that will be split up and determine the number of bootstrap
  # samples to get on each core.
  boot_vec <- 1:B
  
  # Export functions to the cluster.
  clusterExport(
    cluster, 
    list("boot_vec", "one_bootstrap", "bootstrap_replicate_par", "my_vec",
         "my_func"),
    envir=environment()
    )

  estimates <- parSapply(
    cluster,
    boot_vec,
    FUN=bootstrap_replicate_par,
    my_vec=my_vec,
    my_func=my_func
    )

  stopCluster(cluster)

  output <- list(
    'mean' = mean(estimates),
    'se' = sd(estimates),
    'estimates' = estimates
  )

  return(output)
}
```


# Applications

## A. Data Set-up

```{r echo=FALSE}
start_date <- '2000-01-01'
end_date <- '2022-02-26'

getSymbols(
  "^GSPC",
  from=start_date,
  to=end_date,
  warnings=FALSE,
  auto.assign=TRUE
  )

adj_close <- as.vector(GSPC$GSPC.Adjusted)
trading_days <- length(adj_close)
returns <- tail(adj_close, trading_days-1) / head(adj_close, trading_days-1) - 1
```

```{r include=FALSE}
# Create a single-column DataFrame of returns for use with ggplot. 
returns_df <- as.data.frame(returns)

# Create a histogram of daily returns with a KDE overlayed.
returns_hist <- ggplot(returns_df, aes(x=returns)) +
  geom_histogram(aes(y = after_stat(density)),
                 color='darkblue',
                 fill='lightblue',
                 position = 'identity',
                 bins=30) +
  geom_density(bw=0.0025, color='red', size=1) + 
  labs(
    title=paste0('S&P 500 Daily Returns (', start_date, ' to ', end_date, ')'),
    x='returns',
    y='density'
    )

returns_hist
```


## B. Sharpe Ratio


```{r}
sharpe_ratio <- function(returns, rf=0.02/365){
  return(mean(returns - rf)/sd(returns))
}
```

```{r}
sharpe_est <- sharpe_ratio(returns)
sharpe_est
```

```{r}
set.seed(1)
B <- 5000

ptm_loop <- proc.time()
sharpe_est_loop <- bootstrap_loop(returns, sharpe_ratio, B)
loop_time <- proc.time() - ptm_loop

ptm_repl <- proc.time()
sharpe_est_repl <- bootstrap_replicate(returns, sharpe_ratio, B)
repl_time <- proc.time() - ptm_repl

ptm_par <- proc.time()
sharpe_est_par <- bootstrap_parallel(returns, sharpe_ratio, B)
par_time <- proc.time() - ptm_par
```


```{r include=FALSE}
labels <- c('For Loop', 'Optimized Loop', 'Parallelized')
mean_ests <- c(sharpe_est_loop$mean, sharpe_est_repl$mean, sharpe_est_par$mean)
se_ests <- c(sharpe_est_loop$se, sharpe_est_repl$se, sharpe_est_par$se)
elapsed <- matrix(c(loop_time, repl_time, par_time), nrow=3, byrow=TRUE)[,3]
results_df <- as.data.frame(
  list('Method'=labels, 'Mean'=mean_ests, 'SE'=se_ests, 'RunTime'=elapsed)
  )

knitr::kable(
  results_df,
  caption='Comparison of Bootrapped Estimates of Sharpe Ratio'
  )
```

```{r}
sqrt((1 + 0.5*(sharpe_est^2)) / (trading_days - 1))
```


```{r incude=FALSE}
bootstrap_sharpe_df <- as.data.frame(list('sharpe'=sharpe_est_par$estimates))

df <- trading_days - 2

# Define a Student t distribution with shape (nu) and location (mu)
# source: https://stackoverflow.com/questions/46848998/superimposing-asymmetric-t-distribution-using-ggplot2
dt2 <- function(x, mu, nu, df, ncp) {
  dt((x-mu)/nu, df, ncp) / nu
}

ggplot(bootstrap_sharpe_df, aes(x=sharpe)) +
  geom_histogram(
    aes(y=(..density..)),
    color='darkblue',
    fill='lightblue',
    position = 'identity',
    bins=30) +
  stat_function(
    fun=dt2,
    args=list(mu=sharpe_est_par$mean, nu=sharpe_est_par$se, df=df),
    color='red',
    lwd=1
    ) +
  labs(
    title='Bootstrapped Distribution of Sharpe Ratio w/ 95% CI',
    x='Sharpe ratio',
    y='density'
    ) +
  geom_vline(xintercept=sharpe_est_par$mean, linetype='dashed', 
             color='purple',
             size=1) + 
  geom_vline(xintercept=(sharpe_est_par$mean + sharpe_est_par$se 
                         * qt(0.025, df=df)),
             linetype='solid',
             color='black',
             size=1) +
  geom_vline(xintercept=(sharpe_est_par$mean + sharpe_est_par$se 
                         * qt(0.975, df=df)),
             linetype='solid',
             color='black',
             size=1) + 
  geom_vline(xintercept=quantile(sharpe_est_par$estimates, 0.025),
             linetype='dashed',
             color='red',
             size=1) +
  geom_vline(xintercept=quantile(sharpe_est_par$estimates, 0.975),
             linetype='dashed',
             color='red',
             size=1)

```




## B. Value at Risk and Expected Shortfall

```{r}
non_parametric_var <- function(returns, prob=0.05, holdings=1000000){
  return(as.numeric(-holdings*quantile(returns, probs=prob)))
}

non_parametric_es <- function(returns, prob=0.05, holdings=1000000){
  below_quantile <- returns < quantile(returns, probs=prob)
  numer <- sum(returns[below_quantile])
  denom <- sum(below_quantile)
  return(holdings * (numer / denom))
}

var_est <- bootstrap_parallel(returns, non_parametric_var, 100000)
es_est <- bootstrap_parallel(returns, non_parametric_es, 100000)
```


```{r include=FALSE}
var_est_df <- as.data.frame(list('VaR'=var_est$estimates))

var_hist <- ggplot(var_est_df, aes(x=VaR)) +
  geom_histogram(aes(y = after_stat(density)),
                 color='darkblue',
                 fill='lightblue',
                 position = 'identity',
                 bins=30) +
  labs(
    title='5% VaR for $1,000,000 w/ 95% Bootstrapped CIs',
    x='VaR',
    y='density'
    ) +
  geom_vline(xintercept=var_est$mean, linetype='dashed', size=1) +
  geom_vline(xintercept=quantile(var_est$estimates, 0.025), linetype='dashed',
             color='red',
             size=1) +
  geom_vline(xintercept=quantile(var_est$estimates, 0.975), linetype='dashed',
             color='red',
             size=1)

var_hist
```

```{r include=FALSE}
es_est_df <- as.data.frame(list('ES'=es_est$estimates))

es_hist <- ggplot(es_est_df, aes(x=ES)) +
  geom_histogram(aes(y = after_stat(density)),
                 color='darkblue',
                 fill='lightblue',
                 position = 'identity',
                 bins=30) +
  labs(
    title='5% Expected Shortfall for $1,000,000 w/ 95% Bootstrapped CIs',
    x='expected shortfall',
    y='density'
    ) +
  geom_vline(xintercept=es_est$mean, linetype='dashed', size=1) +
  geom_vline(xintercept=quantile(es_est$estimates, 0.025), linetype='dashed',
             color='red',
             size=1) +
  geom_vline(xintercept=quantile(es_est$estimates, 0.975), linetype='dashed',
             color='red',
             size=1)

es_hist
```


